#!/usr/bin/env node
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/lib/zipHelper.ts
import { promises as fsPromises } from "fs";
import path from "path";
import JSZip from "jszip";
import { exec } from "child_process";
function getGitTrackedFiles() {
  return __async(this, null, function* () {
    return new Promise((resolve, reject) => {
      exec("git ls-files", { encoding: "utf-8" }, (error, stdout) => {
        if (error) {
          reject(new Error("Error getting git tracked files"));
        } else {
          resolve(stdout.trim().split("\n"));
        }
      });
    });
  });
}
function getGitDir() {
  return __async(this, null, function* () {
    return new Promise((resolve, reject) => {
      exec(
        "git rev-parse --git-dir",
        { encoding: "utf-8" },
        (error, stdout) => {
          if (error) {
            reject(new Error("Error getting git directory"));
          } else {
            resolve(stdout.trim());
          }
        }
      );
    });
  });
}
function zipRepoJsZip(mainPath, zipRoot, folderToZip) {
  return __async(this, null, function* () {
    if (!folderToZip) folderToZip = zipRoot;
    const filesToInclude = [];
    const gitdir = yield getGitDir();
    const ignoreFilesList = [path.join(gitdir, PL_TMP_PATH)];
    const walk = (currentPath) => __async(this, null, function* () {
      const items = yield fsPromises.readdir(currentPath);
      for (const item of items) {
        const itemPath = path.join(currentPath, item);
        if (ignoreFilesList.some(
          (ignorePath) => itemPath.startsWith(ignorePath)
        )) {
          continue;
        }
        const stats = yield fsPromises.stat(itemPath);
        if (stats.isDirectory()) {
          yield walk(itemPath);
        } else {
          filesToInclude.push(itemPath);
        }
      }
    });
    yield walk(gitdir);
    const gitTrackedFiles = yield getGitTrackedFiles();
    filesToInclude.push(...gitTrackedFiles);
    const zip = new JSZip();
    for (const file of filesToInclude) {
      const content = yield fsPromises.readFile(file);
      const relativePath = `${mainPath ? mainPath + "/" : ""}${path.relative(
        zipRoot,
        file
      )}`;
      zip.file(relativePath, content);
    }
    return yield zip.generateAsync({ type: "nodebuffer" });
  });
}
var PL_TMP_PATH;
var init_zipHelper = __esm({
  "src/lib/zipHelper.ts"() {
    "use strict";
    PL_TMP_PATH = ".protocol.land";
  }
});

// src/lib/common.ts
import Arweave from "arweave";
import { config } from "dotenv";
function getTags(createNewRepo) {
  return __async(this, null, function* () {
    return [
      { name: "App-Name", value: "Protocol.Land" },
      { name: "Content-Type", value: "application/zip" },
      { name: "Creator", value: yield getAddress() },
      { name: "Title", value: getTitle() },
      { name: "Description", value: getDescription() },
      {
        name: "Type",
        value: createNewRepo ? "repo-create" : "repo-update"
      }
    ];
  });
}
var DESCRIPTION_PLACEHOLDER, AOS_PROCESS_ID, isJwk, getWallet, getTitle, getDescription, getOrganizationName, getImportTokenProcessId, getTokenize, initArweave, waitFor, exitWithError;
var init_common = __esm({
  "src/lib/common.ts"() {
    "use strict";
    init_arweaveHelper();
    config();
    DESCRIPTION_PLACEHOLDER = "Decentralized repo description";
    AOS_PROCESS_ID = "yJZ3_Yrc-qYRt1zHmY7YeNvpmQwuqyK3dT0-gxWftew";
    isJwk = (obj) => {
      if (typeof obj !== "object") return false;
      const requiredKeys = ["n", "e", "d", "p", "q", "dp", "dq", "qi"];
      return requiredKeys.every((key) => key in obj);
    };
    getWallet = () => {
      let wallet;
      try {
        wallet = JSON.parse(process.env.WALLET);
      } catch (err) {
      }
      if (isJwk(wallet)) {
        return wallet;
      }
      throw new Error("Arweave wallet key not found or invalid");
    };
    getTitle = () => process.env.REPO_TITLE;
    getDescription = () => process.env.REPO_DESCRIPTION || DESCRIPTION_PLACEHOLDER;
    getOrganizationName = () => process.env.ORGANIZATION_NAME;
    getImportTokenProcessId = () => process.env.IMPORT_TOKEN_PROCESS_ID;
    getTokenize = () => process.env.TOKENIZE;
    initArweave = () => new Arweave({
      host: "ar-io.net",
      port: 443,
      protocol: "https"
    });
    waitFor = (delay) => new Promise((res) => setTimeout(res, delay));
    exitWithError = (message2) => {
      console.error(`
${message2}
`);
      process.exit(1);
    };
  }
});

// src/lib/arweaveHelper.ts
import { ArweaveSigner, createData } from "arbundles";
function getAddress() {
  return __async(this, null, function* () {
    return yield initArweave().wallets.jwkToAddress(getWallet());
  });
}
function uploadRepo(zipBuffer, tags) {
  return __async(this, null, function* () {
    const arweaveTxId = yield arweaveUpload(zipBuffer, tags);
    console.log("Posted Tx to Arweave: ", arweaveTxId);
    return arweaveTxId;
  });
}
function arweaveUpload(zipBuffer, tags) {
  return __async(this, null, function* () {
    if (!jwk) throw "[ arweave ] No jwk wallet supplied";
    const arweave = initArweave();
    const dataSize = zipBuffer.length;
    const tx = yield arweave.createTransaction({ data: zipBuffer }, jwk);
    for (const tag of tags) tx.addTag(tag.name, tag.value);
    yield arweave.transactions.sign(tx, jwk);
    let uploader = yield arweave.transactions.getUploader(tx);
    while (!uploader.isComplete) {
      yield uploader.uploadChunk();
      console.log(
        `${uploader.pctComplete}% complete, ${uploader.uploadedChunks}/${uploader.totalChunks}`
      );
    }
    if (!uploader.isComplete) {
      throw `[ arweave ] Posting repo to arweave failed.
	Error: '${uploader.lastResponseStatus}' - '${uploader.lastResponseError}'
	Check if you have plenty $AR to upload ~${Math.ceil(
        dataSize / 1024
      )} KB of data.`;
    }
    return tx.id;
  });
}
function pollForTxBeingAvailable(_0) {
  return __async(this, arguments, function* ({ txId }) {
    var _a, _b;
    const pollingOptions = {
      maxAttempts: 10,
      pollingIntervalMs: 3e3,
      initialBackoffMs: 7e3
    };
    const { maxAttempts, pollingIntervalMs, initialBackoffMs } = pollingOptions;
    console.log("Polling for transaction...", { txId });
    yield waitFor(initialBackoffMs);
    let attempts = 0;
    while (attempts < maxAttempts) {
      let transaction;
      attempts++;
      try {
        const response = yield initArweave().api.post("/graphql", {
          query: `
          query {
            transaction(id: "${txId}") {
              recipient
              owner {
                address
              }
              quantity {
                winston
              }
            }
          }
          `
        });
        transaction = (_b = (_a = response == null ? void 0 : response.data) == null ? void 0 : _a.data) == null ? void 0 : _b.transaction;
      } catch (err) {
        console.log("Failed to poll for transaction...", { err });
      }
      if (transaction) {
        return;
      }
      console.log("Transaction not found...", {
        txId,
        attempts,
        maxAttempts,
        pollingIntervalMs
      });
      yield waitFor(pollingIntervalMs);
    }
    throw new Error("Transaction not found after polling, transaction id: " + txId);
  });
}
var jwk;
var init_arweaveHelper = __esm({
  "src/lib/arweaveHelper.ts"() {
    "use strict";
    init_common();
    jwk = getWallet();
  }
});

// src/lib/analytics.ts
import * as amplitude from "@amplitude/analytics-node";
var AMPLITUDE_TRACKING_ID, PLATFORM, isInitialized, initializeAmplitudeAnalytics, trackAmplitudeAnalyticsEvent;
var init_analytics = __esm({
  "src/lib/analytics.ts"() {
    "use strict";
    init_arweaveHelper();
    AMPLITUDE_TRACKING_ID = "92a463755ed8c8b96f0f2353a37b7b2";
    PLATFORM = "@protocol.land/sync";
    isInitialized = false;
    initializeAmplitudeAnalytics = () => __async(void 0, null, function* () {
      if (isInitialized) return;
      yield amplitude.init(AMPLITUDE_TRACKING_ID).promise;
      isInitialized = true;
    });
    trackAmplitudeAnalyticsEvent = (category, action, label, data) => __async(void 0, null, function* () {
      try {
        yield initializeAmplitudeAnalytics();
        const userAddress = yield getAddress();
        yield amplitude.track(
          category,
          __spreadValues({
            action,
            label,
            platform: PLATFORM
          }, data),
          {
            user_id: userAddress
          }
        ).promise;
      } catch (error) {
      }
    });
  }
});

// src/lib/aoHelper.ts
import {
  createDataItemSigner,
  dryrun,
  message,
  result,
  spawn
} from "@permaweb/aoconnect";
function capitalizeFirstLetter(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function getTags2(payload) {
  return Object.entries(payload).map(
    ([key, value]) => ({ name: capitalizeFirstLetter(key), value })
  );
}
function extractMessage(text) {
  const regex = /:\s*([^:!]+)!/;
  const match = text.match(regex);
  return match ? match[1].trim() : text;
}
function sendMessage(_0) {
  return __async(this, arguments, function* ({ tags, data }) {
    var _a, _b;
    const args = {
      process: AOS_PROCESS_ID,
      tags,
      signer: createDataItemSigner(getWallet())
    };
    if (data) args.data = data;
    const messageId = yield message(args);
    const { Output } = yield result({
      message: messageId,
      process: AOS_PROCESS_ID
    });
    if ((_a = Output == null ? void 0 : Output.data) == null ? void 0 : _a.output) {
      throw new Error(extractMessage((_b = Output == null ? void 0 : Output.data) == null ? void 0 : _b.output));
    }
    return messageId;
  });
}
function getRepo(name, orgId) {
  return __async(this, null, function* () {
    var _a;
    const address = yield getAddress();
    const tags = {
      Action: "Get-Repo-By-Name-Owner",
      "Repo-Name": name,
      "Owner-Address": address,
      Fields: JSON.stringify(["id", "name", "private", "privateStateTxId"])
    };
    if (orgId) {
      tags["OrgID"] = orgId;
    }
    const { Messages } = yield dryrun({
      process: AOS_PROCESS_ID,
      tags: getTags2(tags)
    });
    if (Messages.length === 0) return void 0;
    return (_a = JSON.parse(Messages[0].Data)) == null ? void 0 : _a.result;
  });
}
function postRepo(dataTxId, repoId, repoInfo) {
  return __async(this, null, function* () {
    if (repoInfo) {
      try {
        const result2 = yield updateRepo(repoInfo.id, dataTxId);
        yield trackAmplitudeAnalyticsEvent(
          "Repository",
          "Add files to repo",
          "Add files",
          {
            repo_name: title,
            repo_id: result2.id,
            result: "SUCCESS"
          }
        );
        return result2;
      } catch (error) {
        yield trackAmplitudeAnalyticsEvent(
          "Repository",
          "Add files to repo",
          "Add files",
          {
            repo_name: title,
            repo_id: repoInfo.id,
            result: "FAILED",
            error: "Failed to update repository"
          }
        );
        throw error;
      }
    } else {
      try {
        let tokenProcessId = getImportTokenProcessId();
        let isTokenImport = true;
        if (!tokenProcessId) {
          tokenProcessId = yield spawnTokenProcess(title);
          isTokenImport = false;
        }
        if (!tokenProcessId) throw "[ AO ] Failed to spawn token process";
        const result2 = yield newRepo(
          repoId,
          dataTxId,
          tokenProcessId,
          isTokenImport
        );
        yield trackAmplitudeAnalyticsEvent(
          "Repository",
          "Successfully created a repo",
          "Create new repo",
          {
            repo_id: result2.id,
            repo_name: title
          }
        );
        return result2;
      } catch (error) {
        yield trackAmplitudeAnalyticsEvent(
          "Repository",
          "Failed to create a new repo",
          "Create new repo"
        );
        throw error;
      }
    }
  });
}
function newRepo(repoId, dataTxId, tokenProcessId, isTokenImport) {
  return __async(this, null, function* () {
    if (!title || !dataTxId || !tokenProcessId)
      throw "[ AO ] No title or dataTx or tokenProcessId for new repo";
    const uploadStrategy = process.env.STRATEGY === "ARSEEDING" ? "ARSEEDING" : "DEFAULT";
    const organizationId = yield getOrganizationId();
    const tokenize = getTokenize();
    yield waitFor(500);
    const tags = {
      Action: "Initialize-Repo",
      Id: repoId,
      Name: title,
      Description: description,
      "Data-TxId": dataTxId,
      "Upload-Strategy": uploadStrategy,
      "Token-Process-Id": tokenProcessId
    };
    if (isTokenImport) {
      tags["Token-Type"] = "IMPORT";
    }
    if (organizationId) {
      tags["OrgId"] = organizationId;
      tags["Creator"] = "ORGANIZATION";
    }
    if (tokenize === "true") {
      tags["Tokenize"] = "true";
    }
    yield sendMessage({
      tags: getTags2(tags)
    });
    console.log(`[ AO ] Repo '${title}' initialized with id '${repoId}'`);
    return { id: repoId };
  });
}
function updateRepo(id, dataTxId) {
  return __async(this, null, function* () {
    if (!id || !title || !dataTxId)
      throw "[ AO ] No id, title or dataTxId to update repo ";
    const uploadStrategy = process.env.STRATEGY === "ARSEEDING" ? "ARSEEDING" : "DEFAULT";
    yield waitFor(500);
    yield sendMessage({
      tags: getTags2({
        Action: "Update-Repo-TxId",
        Id: id,
        "Data-TxId": dataTxId,
        "Upload-Strategy": uploadStrategy
      })
    });
    console.log(`[ AO ] Repo '${title}' with id '${id}' updated`);
    return { id };
  });
}
function spawnTokenProcess(repoName) {
  return __async(this, null, function* () {
    const aosDetails = yield getAosDetails();
    const tags = [
      { name: "App-Name", value: "aos" },
      {
        name: "Name",
        value: repoName + " Repo Token" || "Protocol.Land Repo Token"
      },
      { name: "Process-Type", value: "token" },
      { name: "aos-Version", value: aosDetails.version },
      {
        name: "Authority",
        value: "fcoN_xJeisVsPXA-trzVAuIiqO3ydLQxM-L4XbrQKzY"
      }
    ];
    const pid = yield spawn({
      module: aosDetails.module,
      tags,
      scheduler: aosDetails.scheduler,
      data: "1984",
      signer: createDataItemSigner(getWallet())
    });
    yield pollForTxBeingAvailable({ txId: pid });
    return pid;
  });
}
function getAosDetails() {
  return __async(this, null, function* () {
    var _a;
    const defaultDetails = {
      version: "1.10.22",
      module: "SBNb1qPQ1TDwpD_mboxm2YllmMLXpWw4U8P9Ff8W9vk",
      scheduler: "_GQ33BkPtZrqxA84vM8Zk-N2aO0toNNu_C-l-rawrBA"
    };
    try {
      const response = yield fetch(
        "https://raw.githubusercontent.com/permaweb/aos/main/package.json"
      );
      const pkg = yield response.json();
      const details = {
        version: (pkg == null ? void 0 : pkg.version) || defaultDetails.version,
        module: ((_a = pkg == null ? void 0 : pkg.aos) == null ? void 0 : _a.module) || defaultDetails.module,
        scheduler: defaultDetails.scheduler
      };
      return details;
    } catch (e) {
      return defaultDetails;
    }
  });
}
function resolveOrganizationId(orgName) {
  return __async(this, null, function* () {
    if (!orgName) throw "[ AO ] No organization name";
    const tags = getTags2({
      Action: "Get-Organization-By-Id",
      Id: orgName
    });
    const msgId = yield sendMessage({ tags });
    const { Messages } = yield result({
      message: msgId,
      process: AOS_PROCESS_ID
    });
    if (Messages.length === 0) throw "[ AO ] No organization found";
    const org = JSON.parse(Messages[0].Data);
    if (!org.result) throw "[ AO ] No organization id found";
    return org.result.id;
  });
}
function getOrganizationId() {
  return __async(this, null, function* () {
    const orgName = getOrganizationName();
    let orgId = process.env.ORGANIZATION_ID;
    if (orgName && orgName.length > 0) {
      orgId = yield resolveOrganizationId(orgName);
    }
    return orgId;
  });
}
var title, description;
var init_aoHelper = __esm({
  "src/lib/aoHelper.ts"() {
    "use strict";
    init_common();
    init_arweaveHelper();
    init_analytics();
    title = getTitle();
    description = getDescription();
  }
});

// src/index.ts
import { v4 as uuidv4 } from "uuid";
var require_index = __commonJS({
  "src/index.ts"(exports) {
    init_zipHelper();
    init_arweaveHelper();
    init_aoHelper();
    init_common();
    var PATH = ".";
    var FOLDER_TO_ZIP = ".";
    var NAME_REGEX = /^[a-zA-Z0-9._-]+$/;
    var title2 = getTitle();
    function main() {
      return __async(this, null, function* () {
        const orgId = yield getOrganizationId();
        if (!NAME_REGEX.test(title2))
          exitWithError(
            `[ PL Sync ] Repo name can ONLY contain ASCII letters, digits and the characters '.', '-', and '_'`
          );
        console.log(`[ PL Sync ] Starting sync for repo '${title2}'`);
        const repoInfo = yield getRepo(title2, orgId);
        const repoId = (repoInfo == null ? void 0 : repoInfo.id) || uuidv4();
        let zipBuffer;
        try {
          zipBuffer = yield zipRepoJsZip(repoId, PATH, FOLDER_TO_ZIP);
        } catch (error) {
          console.error("Error zipping repository:", error);
          process.exit(1);
        }
        const tags = yield getTags(!repoInfo ? true : false);
        try {
          const isPrivate = (repoInfo == null ? void 0 : repoInfo.private) || false;
          const privateStateTxId = repoInfo == null ? void 0 : repoInfo.privateStateTxId;
          if (isPrivate && privateStateTxId) {
            throw new Error("Private repos are not supported.");
          }
          const dataTxId = yield uploadRepo(zipBuffer, tags);
          if (dataTxId) yield postRepo(dataTxId, repoId, repoInfo);
        } catch (error) {
          exitWithError(error);
        }
      });
    }
    (() => __async(exports, null, function* () {
      yield main();
    }))();
  }
});
export default require_index();
