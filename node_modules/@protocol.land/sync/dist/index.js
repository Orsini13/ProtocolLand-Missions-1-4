#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var import_uuid = require("uuid");

// src/lib/zipHelper.ts
var import_fs = require("fs");
var import_path = __toESM(require("path"));
var import_jszip = __toESM(require("jszip"));
var import_child_process = require("child_process");
var PL_TMP_PATH = ".protocol.land";
function getGitTrackedFiles() {
  return __async(this, null, function* () {
    return new Promise((resolve, reject) => {
      (0, import_child_process.exec)("git ls-files", { encoding: "utf-8" }, (error, stdout) => {
        if (error) {
          reject(new Error("Error getting git tracked files"));
        } else {
          resolve(stdout.trim().split("\n"));
        }
      });
    });
  });
}
function getGitDir() {
  return __async(this, null, function* () {
    return new Promise((resolve, reject) => {
      (0, import_child_process.exec)(
        "git rev-parse --git-dir",
        { encoding: "utf-8" },
        (error, stdout) => {
          if (error) {
            reject(new Error("Error getting git directory"));
          } else {
            resolve(stdout.trim());
          }
        }
      );
    });
  });
}
function zipRepoJsZip(mainPath, zipRoot, folderToZip) {
  return __async(this, null, function* () {
    if (!folderToZip) folderToZip = zipRoot;
    const filesToInclude = [];
    const gitdir = yield getGitDir();
    const ignoreFilesList = [import_path.default.join(gitdir, PL_TMP_PATH)];
    const walk = (currentPath) => __async(this, null, function* () {
      const items = yield import_fs.promises.readdir(currentPath);
      for (const item of items) {
        const itemPath = import_path.default.join(currentPath, item);
        if (ignoreFilesList.some(
          (ignorePath) => itemPath.startsWith(ignorePath)
        )) {
          continue;
        }
        const stats = yield import_fs.promises.stat(itemPath);
        if (stats.isDirectory()) {
          yield walk(itemPath);
        } else {
          filesToInclude.push(itemPath);
        }
      }
    });
    yield walk(gitdir);
    const gitTrackedFiles = yield getGitTrackedFiles();
    filesToInclude.push(...gitTrackedFiles);
    const zip = new import_jszip.default();
    for (const file of filesToInclude) {
      const content = yield import_fs.promises.readFile(file);
      const relativePath = `${mainPath ? mainPath + "/" : ""}${import_path.default.relative(
        zipRoot,
        file
      )}`;
      zip.file(relativePath, content);
    }
    return yield zip.generateAsync({ type: "nodebuffer" });
  });
}

// src/lib/common.ts
var import_arweave = __toESM(require("arweave"));
var import_dotenv = require("dotenv");
(0, import_dotenv.config)();
var DESCRIPTION_PLACEHOLDER = "Decentralized repo description";
var AOS_PROCESS_ID = "yJZ3_Yrc-qYRt1zHmY7YeNvpmQwuqyK3dT0-gxWftew";
var isJwk = (obj) => {
  if (typeof obj !== "object") return false;
  const requiredKeys = ["n", "e", "d", "p", "q", "dp", "dq", "qi"];
  return requiredKeys.every((key) => key in obj);
};
var getWallet = () => {
  let wallet;
  try {
    wallet = JSON.parse(process.env.WALLET);
  } catch (err) {
  }
  if (isJwk(wallet)) {
    return wallet;
  }
  throw new Error("Arweave wallet key not found or invalid");
};
var getTitle = () => process.env.REPO_TITLE;
var getDescription = () => process.env.REPO_DESCRIPTION || DESCRIPTION_PLACEHOLDER;
var getOrganizationName = () => process.env.ORGANIZATION_NAME;
var getImportTokenProcessId = () => process.env.IMPORT_TOKEN_PROCESS_ID;
var getTokenize = () => process.env.TOKENIZE;
var initArweave = () => new import_arweave.default({
  host: "ar-io.net",
  port: 443,
  protocol: "https"
});
function getTags(createNewRepo) {
  return __async(this, null, function* () {
    return [
      { name: "App-Name", value: "Protocol.Land" },
      { name: "Content-Type", value: "application/zip" },
      { name: "Creator", value: yield getAddress() },
      { name: "Title", value: getTitle() },
      { name: "Description", value: getDescription() },
      {
        name: "Type",
        value: createNewRepo ? "repo-create" : "repo-update"
      }
    ];
  });
}
var waitFor = (delay) => new Promise((res) => setTimeout(res, delay));
var exitWithError = (message2) => {
  console.error(`
${message2}
`);
  process.exit(1);
};

// src/lib/arweaveHelper.ts
var import_arbundles = require("arbundles");
var jwk = getWallet();
function getAddress() {
  return __async(this, null, function* () {
    return yield initArweave().wallets.jwkToAddress(getWallet());
  });
}
function uploadRepo(zipBuffer, tags) {
  return __async(this, null, function* () {
    const arweaveTxId = yield arweaveUpload(zipBuffer, tags);
    console.log("Posted Tx to Arweave: ", arweaveTxId);
    return arweaveTxId;
  });
}
function arweaveUpload(zipBuffer, tags) {
  return __async(this, null, function* () {
    if (!jwk) throw "[ arweave ] No jwk wallet supplied";
    const arweave = initArweave();
    const dataSize = zipBuffer.length;
    const tx = yield arweave.createTransaction({ data: zipBuffer }, jwk);
    for (const tag of tags) tx.addTag(tag.name, tag.value);
    yield arweave.transactions.sign(tx, jwk);
    let uploader = yield arweave.transactions.getUploader(tx);
    while (!uploader.isComplete) {
      yield uploader.uploadChunk();
      console.log(
        `${uploader.pctComplete}% complete, ${uploader.uploadedChunks}/${uploader.totalChunks}`
      );
    }
    if (!uploader.isComplete) {
      throw `[ arweave ] Posting repo to arweave failed.
	Error: '${uploader.lastResponseStatus}' - '${uploader.lastResponseError}'
	Check if you have plenty $AR to upload ~${Math.ceil(
        dataSize / 1024
      )} KB of data.`;
    }
    return tx.id;
  });
}
function pollForTxBeingAvailable(_0) {
  return __async(this, arguments, function* ({ txId }) {
    var _a, _b;
    const pollingOptions = {
      maxAttempts: 10,
      pollingIntervalMs: 3e3,
      initialBackoffMs: 7e3
    };
    const { maxAttempts, pollingIntervalMs, initialBackoffMs } = pollingOptions;
    console.log("Polling for transaction...", { txId });
    yield waitFor(initialBackoffMs);
    let attempts = 0;
    while (attempts < maxAttempts) {
      let transaction;
      attempts++;
      try {
        const response = yield initArweave().api.post("/graphql", {
          query: `
          query {
            transaction(id: "${txId}") {
              recipient
              owner {
                address
              }
              quantity {
                winston
              }
            }
          }
          `
        });
        transaction = (_b = (_a = response == null ? void 0 : response.data) == null ? void 0 : _a.data) == null ? void 0 : _b.transaction;
      } catch (err) {
        console.log("Failed to poll for transaction...", { err });
      }
      if (transaction) {
        return;
      }
      console.log("Transaction not found...", {
        txId,
        attempts,
        maxAttempts,
        pollingIntervalMs
      });
      yield waitFor(pollingIntervalMs);
    }
    throw new Error("Transaction not found after polling, transaction id: " + txId);
  });
}

// src/lib/aoHelper.ts
var import_aoconnect = require("@permaweb/aoconnect");

// src/lib/analytics.ts
var amplitude = __toESM(require("@amplitude/analytics-node"));
var AMPLITUDE_TRACKING_ID = "92a463755ed8c8b96f0f2353a37b7b2";
var PLATFORM = "@protocol.land/sync";
var isInitialized = false;
var initializeAmplitudeAnalytics = () => __async(void 0, null, function* () {
  if (isInitialized) return;
  yield amplitude.init(AMPLITUDE_TRACKING_ID).promise;
  isInitialized = true;
});
var trackAmplitudeAnalyticsEvent = (category, action, label, data) => __async(void 0, null, function* () {
  try {
    yield initializeAmplitudeAnalytics();
    const userAddress = yield getAddress();
    yield amplitude.track(
      category,
      __spreadValues({
        action,
        label,
        platform: PLATFORM
      }, data),
      {
        user_id: userAddress
      }
    ).promise;
  } catch (error) {
  }
});

// src/lib/aoHelper.ts
var title = getTitle();
var description = getDescription();
function capitalizeFirstLetter(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function getTags2(payload) {
  return Object.entries(payload).map(
    ([key, value]) => ({ name: capitalizeFirstLetter(key), value })
  );
}
function extractMessage(text) {
  const regex = /:\s*([^:!]+)!/;
  const match = text.match(regex);
  return match ? match[1].trim() : text;
}
function sendMessage(_0) {
  return __async(this, arguments, function* ({ tags, data }) {
    var _a, _b;
    const args = {
      process: AOS_PROCESS_ID,
      tags,
      signer: (0, import_aoconnect.createDataItemSigner)(getWallet())
    };
    if (data) args.data = data;
    const messageId = yield (0, import_aoconnect.message)(args);
    const { Output } = yield (0, import_aoconnect.result)({
      message: messageId,
      process: AOS_PROCESS_ID
    });
    if ((_a = Output == null ? void 0 : Output.data) == null ? void 0 : _a.output) {
      throw new Error(extractMessage((_b = Output == null ? void 0 : Output.data) == null ? void 0 : _b.output));
    }
    return messageId;
  });
}
function getRepo(name, orgId) {
  return __async(this, null, function* () {
    var _a;
    const address = yield getAddress();
    const tags = {
      Action: "Get-Repo-By-Name-Owner",
      "Repo-Name": name,
      "Owner-Address": address,
      Fields: JSON.stringify(["id", "name", "private", "privateStateTxId"])
    };
    if (orgId) {
      tags["OrgID"] = orgId;
    }
    const { Messages } = yield (0, import_aoconnect.dryrun)({
      process: AOS_PROCESS_ID,
      tags: getTags2(tags)
    });
    if (Messages.length === 0) return void 0;
    return (_a = JSON.parse(Messages[0].Data)) == null ? void 0 : _a.result;
  });
}
function postRepo(dataTxId, repoId, repoInfo) {
  return __async(this, null, function* () {
    if (repoInfo) {
      try {
        const result2 = yield updateRepo(repoInfo.id, dataTxId);
        yield trackAmplitudeAnalyticsEvent(
          "Repository",
          "Add files to repo",
          "Add files",
          {
            repo_name: title,
            repo_id: result2.id,
            result: "SUCCESS"
          }
        );
        return result2;
      } catch (error) {
        yield trackAmplitudeAnalyticsEvent(
          "Repository",
          "Add files to repo",
          "Add files",
          {
            repo_name: title,
            repo_id: repoInfo.id,
            result: "FAILED",
            error: "Failed to update repository"
          }
        );
        throw error;
      }
    } else {
      try {
        let tokenProcessId = getImportTokenProcessId();
        let isTokenImport = true;
        if (!tokenProcessId) {
          tokenProcessId = yield spawnTokenProcess(title);
          isTokenImport = false;
        }
        if (!tokenProcessId) throw "[ AO ] Failed to spawn token process";
        const result2 = yield newRepo(
          repoId,
          dataTxId,
          tokenProcessId,
          isTokenImport
        );
        yield trackAmplitudeAnalyticsEvent(
          "Repository",
          "Successfully created a repo",
          "Create new repo",
          {
            repo_id: result2.id,
            repo_name: title
          }
        );
        return result2;
      } catch (error) {
        yield trackAmplitudeAnalyticsEvent(
          "Repository",
          "Failed to create a new repo",
          "Create new repo"
        );
        throw error;
      }
    }
  });
}
function newRepo(repoId, dataTxId, tokenProcessId, isTokenImport) {
  return __async(this, null, function* () {
    if (!title || !dataTxId || !tokenProcessId)
      throw "[ AO ] No title or dataTx or tokenProcessId for new repo";
    const uploadStrategy = process.env.STRATEGY === "ARSEEDING" ? "ARSEEDING" : "DEFAULT";
    const organizationId = yield getOrganizationId();
    const tokenize = getTokenize();
    yield waitFor(500);
    const tags = {
      Action: "Initialize-Repo",
      Id: repoId,
      Name: title,
      Description: description,
      "Data-TxId": dataTxId,
      "Upload-Strategy": uploadStrategy,
      "Token-Process-Id": tokenProcessId
    };
    if (isTokenImport) {
      tags["Token-Type"] = "IMPORT";
    }
    if (organizationId) {
      tags["OrgId"] = organizationId;
      tags["Creator"] = "ORGANIZATION";
    }
    if (tokenize === "true") {
      tags["Tokenize"] = "true";
    }
    yield sendMessage({
      tags: getTags2(tags)
    });
    console.log(`[ AO ] Repo '${title}' initialized with id '${repoId}'`);
    return { id: repoId };
  });
}
function updateRepo(id, dataTxId) {
  return __async(this, null, function* () {
    if (!id || !title || !dataTxId)
      throw "[ AO ] No id, title or dataTxId to update repo ";
    const uploadStrategy = process.env.STRATEGY === "ARSEEDING" ? "ARSEEDING" : "DEFAULT";
    yield waitFor(500);
    yield sendMessage({
      tags: getTags2({
        Action: "Update-Repo-TxId",
        Id: id,
        "Data-TxId": dataTxId,
        "Upload-Strategy": uploadStrategy
      })
    });
    console.log(`[ AO ] Repo '${title}' with id '${id}' updated`);
    return { id };
  });
}
function spawnTokenProcess(repoName) {
  return __async(this, null, function* () {
    const aosDetails = yield getAosDetails();
    const tags = [
      { name: "App-Name", value: "aos" },
      {
        name: "Name",
        value: repoName + " Repo Token" || "Protocol.Land Repo Token"
      },
      { name: "Process-Type", value: "token" },
      { name: "aos-Version", value: aosDetails.version },
      {
        name: "Authority",
        value: "fcoN_xJeisVsPXA-trzVAuIiqO3ydLQxM-L4XbrQKzY"
      }
    ];
    const pid = yield (0, import_aoconnect.spawn)({
      module: aosDetails.module,
      tags,
      scheduler: aosDetails.scheduler,
      data: "1984",
      signer: (0, import_aoconnect.createDataItemSigner)(getWallet())
    });
    yield pollForTxBeingAvailable({ txId: pid });
    return pid;
  });
}
function getAosDetails() {
  return __async(this, null, function* () {
    var _a;
    const defaultDetails = {
      version: "1.10.22",
      module: "SBNb1qPQ1TDwpD_mboxm2YllmMLXpWw4U8P9Ff8W9vk",
      scheduler: "_GQ33BkPtZrqxA84vM8Zk-N2aO0toNNu_C-l-rawrBA"
    };
    try {
      const response = yield fetch(
        "https://raw.githubusercontent.com/permaweb/aos/main/package.json"
      );
      const pkg = yield response.json();
      const details = {
        version: (pkg == null ? void 0 : pkg.version) || defaultDetails.version,
        module: ((_a = pkg == null ? void 0 : pkg.aos) == null ? void 0 : _a.module) || defaultDetails.module,
        scheduler: defaultDetails.scheduler
      };
      return details;
    } catch (e) {
      return defaultDetails;
    }
  });
}
function resolveOrganizationId(orgName) {
  return __async(this, null, function* () {
    if (!orgName) throw "[ AO ] No organization name";
    const tags = getTags2({
      Action: "Get-Organization-By-Id",
      Id: orgName
    });
    const msgId = yield sendMessage({ tags });
    const { Messages } = yield (0, import_aoconnect.result)({
      message: msgId,
      process: AOS_PROCESS_ID
    });
    if (Messages.length === 0) throw "[ AO ] No organization found";
    const org = JSON.parse(Messages[0].Data);
    if (!org.result) throw "[ AO ] No organization id found";
    return org.result.id;
  });
}
function getOrganizationId() {
  return __async(this, null, function* () {
    const orgName = getOrganizationName();
    let orgId = process.env.ORGANIZATION_ID;
    if (orgName && orgName.length > 0) {
      orgId = yield resolveOrganizationId(orgName);
    }
    return orgId;
  });
}

// src/index.ts
var PATH = ".";
var FOLDER_TO_ZIP = ".";
var NAME_REGEX = /^[a-zA-Z0-9._-]+$/;
var title2 = getTitle();
function main() {
  return __async(this, null, function* () {
    const orgId = yield getOrganizationId();
    if (!NAME_REGEX.test(title2))
      exitWithError(
        `[ PL Sync ] Repo name can ONLY contain ASCII letters, digits and the characters '.', '-', and '_'`
      );
    console.log(`[ PL Sync ] Starting sync for repo '${title2}'`);
    const repoInfo = yield getRepo(title2, orgId);
    const repoId = (repoInfo == null ? void 0 : repoInfo.id) || (0, import_uuid.v4)();
    let zipBuffer;
    try {
      zipBuffer = yield zipRepoJsZip(repoId, PATH, FOLDER_TO_ZIP);
    } catch (error) {
      console.error("Error zipping repository:", error);
      process.exit(1);
    }
    const tags = yield getTags(!repoInfo ? true : false);
    try {
      const isPrivate = (repoInfo == null ? void 0 : repoInfo.private) || false;
      const privateStateTxId = repoInfo == null ? void 0 : repoInfo.privateStateTxId;
      if (isPrivate && privateStateTxId) {
        throw new Error("Private repos are not supported.");
      }
      const dataTxId = yield uploadRepo(zipBuffer, tags);
      if (dataTxId) yield postRepo(dataTxId, repoId, repoInfo);
    } catch (error) {
      exitWithError(error);
    }
  });
}
(() => __async(exports, null, function* () {
  yield main();
}))();
